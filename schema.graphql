"An address for emailing with"
scalar Email

"escaped, HTML-renderable content"
scalar HTML

"An ISO8601 DateTime"
scalar Timestamp

"a Universal Resource Locator"
scalar URL

"a pagination-spec compatible PageInfo"
type PageInfo {
    startCursor: ID
    endCursor: ID
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
}

"a pagination-spec compatible Edge interface"
interface Edge {
    cursor: ID!
}

"a pagination-spec compatible Connection interface"
interface Connection {
    totalCount: Int!
    pageInfo: PageInfo!
}

# === generic inputs
input NumFilter {
    gt: Int
    lt: Int
}

input StringFilter {
    present: Boolean
    matches: String
}

# === domain objects & related
type Badge {
    id: ID!
    name: String!
    date: Timestamp!
    user: User!
}

type Question {
    id: ID!
    created: Timestamp!
    title: String!
    body: HTML!
    score: Int!
    views: Int!
    author: User!

    "the answer marked as accepted"
    acceptedAnswer: Answer

    "answers not marked as accepted, sorted by the highest score"
    unacceptedAnswers(
        first: Int
    ): AnswerConnection!
}

type QuestionEdge implements Edge {
    cursor: ID!
    node: Question!
}

type QuestionConnection implements Connection {
    totalCount: Int!
    pageInfo: PageInfo!
    edges: [QuestionEdge!]!
    totalScore: Int!
}

input QuestionFilter {
    score: NumFilter
    title: StringFilter
    views: NumFilter
    author: UserFilter
    authorIs: ID
    answered: Boolean
}

enum PostSort {
    "sort by the most recent questions"
    RECENT
    "sort by the highest score"
    SCORE
    "sort by the most views (works for questions only)"
    VIEWS
}

type Answer {
    id: ID!
    created: Timestamp!
    body: HTML!
    score: Int!
    author: User!
    parent: Question!
    isAcceptedAnswer: Boolean!
}

type AnswerEdge {
    cursor: ID!
    node: Answer!
}

type AnswerConnection {
    totalCount: Int!
    pageInfo: PageInfo!
    edges: [AnswerEdge!]!
    totalScore: Int!
}

union Post = Question | Answer

type User {
    id: ID!
    reputation: Int!
    created: Timestamp!
    displayName: String!
    lastAccessed: Timestamp!
    location: String
    aboutMe: HTML
    views: Int!
    upVotes: Int!
    downVotes: Int!
    profileImageUrl: URL
    websiteUrl: URL
    badgeCount: Int!
    badges: [Badge!]!
    questions(
        first: Int
        last: Int
        filter: QuestionFilter
        sort: PostSort
    ): QuestionConnection!
    answers(
        first: Int
        sort: PostSort
    ): AnswerConnection!
}

type UserEdge implements Edge {
    cursor: ID!
    node: User!
}

type UserConnection implements Connection {
    totalCount: Int!
    pageInfo: PageInfo!
    edges: [UserEdge!]!
}

input UserFilter {
    reputation: NumFilter
    displayName: StringFilter
    websiteUrl: StringFilter
    hasBadge: String
}

enum UserSort {
    "sort by the user's creation date"
    CREATED
    "sort alphabetically by the user's display name"
    DISPLAY_NAME
    "sort by the highest reputation"
    REPUTATION
    "sort by the most recently accessed user"
    RECENTLY_ACCESSED
    "sort by the most badges"
    BADGES
    "sort by the highest question count"
    QUESTION_COUNT
    "sort by the highest sum of question scores"
    QUESTION_SCORES
}

type Query {
    questionSearch(
        first: Int
        after: ID
        last: Int
        before: ID
        filter: QuestionFilter
        sort: PostSort
    ): QuestionConnection!

    userById(id: ID!): User
    userSearch(
        first: Int
        after: ID
        last: Int
        before: ID
        filter: UserFilter
        sort: UserSort
    ): UserConnection!
}
